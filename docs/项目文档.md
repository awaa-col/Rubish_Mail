# Rubbish Mail - 项目完整文档

## 项目概述

**项目名称**: Rubbish Mail - 临时邮箱监控服务  
**技术栈**: Python 3.9+ | FastAPI | WebSocket | aioimaplib | Pydantic  
**核心功能**: 异步监控指定邮箱,根据规则匹配邮件并实时推送给客户端

## 架构设计

### 技术选型理由

1. **FastAPI**: 现代异步框架,原生支持WebSocket,性能优异
2. **aioimaplib**: 异步IMAP客户端,支持并发监控多个邮箱
3. **WebSocket**: 双向实时通信,适合消息推送场景
4. **Pydantic**: 数据验证,确保类型安全

### 项目结构

```
rubbish_mail/
├── core/                  # 核心业务逻辑
│   ├── config.py         # 配置管理
│   ├── auth.py           # 认证系统
│   └── imap_monitor.py   # IMAP监控
├── schemas/              # 数据模型
│   └── request.py        # 请求/响应模型
├── utils/                # 工具函数
│   └── matcher.py        # 规则匹配器
├── logs/                 # 日志文件
├── main.py               # 应用入口
├── example_client.py     # 客户端示例
└── 白岚/                 # 项目文档
```

---

## 核心模块详解

## 1. 配置管理模块 (core/config.py)

### 职责
- 从 `config.yml` 加载服务配置
- 从 `.env` 加载敏感信息(API密钥)
- 提供全局配置访问接口

### 类与函数

#### `ServerConfig`
**目的**: 服务器配置  
**字段**:
- `host: str` - 监听地址
- `port: int` - 监听端口
- `reload: bool` - 热重载开关

#### `IMAPConfig`
**目的**: IMAP服务器配置  
**字段**:
- `host: str` - IMAP服务器地址
- `port: int` - IMAP端口(默认993)
- `use_ssl: bool` - 是否使用SSL
- `allowed_domain: str` - 允许的邮箱域名
- `admin_user: str` - 管理员账户(可选)
- `admin_password: str` - 管理员密码(可选)

#### `MonitorConfig`
**目的**: 监控行为配置  
**字段**:
- `check_interval: int` - 检查邮件间隔(秒)
- `max_connections: int` - 最大并发连接数
- `timeout: int` - WebSocket超时(秒)
- `mark_as_read: bool` - 是否标记已读

#### `LoggingConfig`
**目的**: 日志配置  
**字段**:
- `level: str` - 日志级别(INFO/DEBUG/...)
- `file: str` - 日志文件路径

#### `Settings`
**目的**: 全局配置聚合  
**字段**:
- `api_key: str` - 主API密钥
- `api_keys: List[str]` - 额外API密钥列表
- `server: ServerConfig`
- `imap: IMAPConfig`
- `monitor: MonitorConfig`
- `logging: LoggingConfig`

**方法**:
- `get_valid_api_keys() -> List[str]`
  - **输入**: 无
  - **输出**: 所有有效API密钥的去重列表
  - **目的**: 合并主密钥和额外密钥

#### `load_config(config_path: str = "config.yml") -> Settings`
**目的**: 加载并解析配置文件  
**输入**:
- `config_path: str` - 配置文件路径
**输出**: `Settings` 对象  
**异常**:
- `FileNotFoundError` - 配置文件不存在
- `ValueError` - API_KEY环境变量缺失
- `yaml.YAMLError` - YAML格式错误

#### `get_settings() -> Settings`
**目的**: 获取全局配置实例(单例模式)  
**输入**: 无  
**输出**: `Settings` 对象

---

## 2. 数据模型模块 (schemas/request.py)

### 职责
- 定义所有请求/响应的数据结构
- 使用Pydantic进行自动验证
- 确保类型安全

### 数据模型

#### `MatchRule`
**目的**: 邮件匹配规则  
**字段**:
- `type: Literal["keyword", "regex"]` - 匹配类型
- `patterns: List[str]` - 匹配模式列表(OR关系)
- `search_in: List[str]` - 搜索范围(sender/subject/body)

**验证器**:
- `validate_patterns()` - 确保patterns非空且去除空白

#### `MonitorRequest`
**目的**: 客户端监控请求  
**字段**:
- `api_key: str` - API密钥
- `email: EmailStr` - 监控的邮箱地址
- `rules: List[MatchRule]` - 匹配规则列表

**验证器**:
- `validate_email_format()` - 验证邮箱格式并转小写

#### `EmailContent`
**目的**: 邮件内容(推送给客户端)  
**字段**:
- `sender: str` - 发件人邮箱
- `sender_name: str | None` - 发件人姓名
- `subject: str` - 邮件主题
- `body: str` - 正文(纯文本)
- `html_body: str | None` - HTML正文
- `received_time: str` - 接收时间(ISO格式)
- `matched_rule: str` - 匹配的规则描述

#### `WebSocketMessage`
**目的**: WebSocket消息基类  
**字段**:
- `type: str` - 消息类型
- `data: dict | None` - 消息数据

#### `MonitorStartMessage`
**目的**: 监控启动确认消息  
**继承**: `WebSocketMessage`  
**字段**:
- `type = "monitor_start"`
- `data: dict` - 包含监控状态信息

#### `EmailReceivedMessage`
**目的**: 邮件接收通知  
**继承**: `WebSocketMessage`  
**字段**:
- `type = "email_received"`
- `data: EmailContent` - 邮件内容

#### `ErrorMessage`
**目的**: 错误通知  
**继承**: `WebSocketMessage`  
**字段**:
- `type = "error"`
- `data: dict` - 包含code和message

#### `HeartbeatMessage`
**目的**: 心跳保活  
**继承**: `WebSocketMessage`  
**字段**:
- `type = "heartbeat"`
- `data: dict` - 包含timestamp

---

## 3. 规则匹配模块 (utils/matcher.py)

### 职责
- 根据规则匹配邮件内容
- 支持关键词和正则表达式
- 返回匹配结果和描述

### 类与函数

#### `EmailMatcher`
**目的**: 邮件匹配器(静态方法类)

##### `match(rule: MatchRule, email_data: Dict) -> Tuple[bool, str]`
**目的**: 检查邮件是否匹配单个规则  
**输入**:
- `rule: MatchRule` - 匹配规则
- `email_data: Dict` - 邮件数据,包含sender/subject/body

**输出**: `(是否匹配, 匹配描述)`  
- 匹配示例: `(True, "关键词 '验证码' 匹配于主题")`
- 不匹配: `(False, "")`

**调用链**: `match -> _match_keyword | _match_regex`

##### `_match_keyword(patterns: List[str], search_contents: Dict) -> Tuple[bool, str]`
**目的**: 关键词匹配(不区分大小写)  
**输入**:
- `patterns: List[str]` - 关键词列表
- `search_contents: Dict[str, str]` - {字段名: 内容}

**输出**: `(是否匹配, 匹配描述)`  
**逻辑**: 遍历所有字段和模式,只要有一个匹配就返回True

##### `_match_regex(patterns: List[str], search_contents: Dict) -> Tuple[bool, str]`
**目的**: 正则表达式匹配  
**输入**:
- `patterns: List[str]` - 正则表达式列表
- `search_contents: Dict[str, str]` - {字段名: 内容}

**输出**: `(是否匹配, 匹配描述)`  
**异常处理**: 捕获正则错误并返回错误描述

##### `match_any(rules: List[MatchRule], email_data: Dict) -> Tuple[bool, str]`
**目的**: 检查邮件是否匹配任意规则(OR逻辑)  
**输入**:
- `rules: List[MatchRule]` - 规则列表
- `email_data: Dict` - 邮件数据

**输出**: `(是否匹配, 第一个匹配的规则描述)`  
**调用链**: `match_any -> match -> _match_keyword | _match_regex`

---

## 4. 认证模块 (core/auth.py)

### 职责
- 验证客户端API密钥
- 提供全局认证实例

### 类与函数

#### `APIKeyAuth`
**目的**: API密钥认证器

##### `__init__(valid_keys: List[str])`
**输入**: `valid_keys` - 有效密钥列表  
**目的**: 初始化认证器,将密钥存为set提高查找效率

##### `verify(api_key: str) -> bool`
**目的**: 验证API密钥  
**输入**: `api_key: str` - 待验证密钥  
**输出**: `True`=有效, `False`=无效

##### `verify_or_raise(api_key: str) -> None`
**目的**: 验证密钥,失败则抛出HTTP异常  
**输入**: `api_key: str`  
**异常**: `HTTPException(401)` - 认证失败

#### `init_auth(valid_keys: List[str]) -> None`
**目的**: 初始化全局认证器实例  
**输入**: `valid_keys` - 有效密钥列表  
**调用时机**: 应用启动时

#### `get_auth() -> APIKeyAuth`
**目的**: 获取全局认证器实例  
**输出**: `APIKeyAuth` 实例  
**异常**: `RuntimeError` - 认证器未初始化

---

## 5. IMAP监控核心 (core/imap_monitor.py)

### 职责
- 连接IMAP服务器
- 异步监控邮箱新邮件
- 解析邮件内容
- 匹配规则并推送

### 类与函数

#### `EmailMonitor`
**目的**: 邮件监控器(每个WebSocket连接创建一个实例)

##### `__init__(...)`
**输入**:
- `imap_host: str` - IMAP服务器地址
- `imap_port: int` - IMAP端口
- `use_ssl: bool` - 是否使用SSL
- `email_address: str` - 监控的邮箱地址
- `email_password: str` - 邮箱密码
- `rules: List[MatchRule]` - 匹配规则
- `callback: Callable` - 邮件推送回调函数
- `check_interval: int` - 检查间隔(秒)
- `mark_as_read: bool` - 是否标记已读

**目的**: 初始化监控器参数

##### `async start() -> None`
**目的**: 启动监控  
**调用链**: `start -> wait_hello -> login -> select -> _monitor_loop`  
**异常**: `ConnectionError` - 连接/登录失败

**执行流程**:
1. 连接IMAP服务器(SSL/非SSL)
2. 等待服务器Hello
3. 登录邮箱
4. 选择INBOX
5. 启动监控循环

##### `async stop() -> None`
**目的**: 停止监控并清理资源  
**调用链**: `stop -> cancel(monitor_task) -> logout`

##### `async _monitor_loop() -> None`
**目的**: 监控循环,定期检查新邮件  
**调用链**: `_monitor_loop -> _check_new_emails -> sleep -> _monitor_loop`  
**逻辑**: 
- 每 `check_interval` 秒检查一次
- 捕获异常继续运行
- 直到 `is_running=False`

##### `async _check_new_emails() -> None`
**目的**: 检查新邮件  
**调用链**: `_check_new_emails -> search(UNSEEN) -> _process_email`  
**逻辑**:
1. 搜索未读邮件(UNSEEN)
2. 解析UID列表
3. 过滤已处理的UID
4. 逐个处理新邮件

##### `async _process_email(uid: str) -> None`
**目的**: 处理单封邮件  
**调用链**: `_process_email -> fetch -> _parse_email -> EmailMatcher.match_any -> callback -> _mark_as_read`

**执行流程**:
1. 获取邮件完整内容(RFC822)
2. 解析邮件(调用 `_parse_email`)
3. 匹配规则(调用 `EmailMatcher.match_any`)
4. 如果匹配:
   - 构造 `EmailContent` 对象
   - 调用回调推送给客户端
   - 标记为已读(如果启用)

##### `async _mark_as_read(uid: str) -> None`
**目的**: 标记邮件为已读  
**输入**: `uid: str` - 邮件UID  
**调用链**: `_mark_as_read -> store(uid, +FLAGS, \\Seen)`

##### `_parse_email(lines: List[bytes]) -> Optional[Dict]`
**目的**: 解析邮件内容  
**输入**: `lines: List[bytes]` - IMAP FETCH返回的数据  
**输出**: 包含sender/subject/body等字段的字典  
**调用链**: `_parse_email -> _decode_header_value -> _get_email_body`

**解析内容**:
- 发件人(From): 提取邮箱和姓名
- 主题(Subject): 解码MIME编码
- 正文: 解析text/plain和text/html
- 时间(Date): 转为ISO格式

##### `_decode_header_value(value: str) -> str`
**目的**: 解码邮件头部(MIME编码)  
**输入**: `value: str` - 原始头部值  
**输出**: 解码后的UTF-8字符串

##### `_get_email_body(msg) -> str`
**目的**: 从邮件对象提取正文  
**输入**: `msg: email.message.Message`  
**输出**: 正文字符串(UTF-8)

---

## 6. FastAPI应用 (main.py)

### 职责
- 提供WebSocket端点
- 管理监控任务生命周期
- 处理客户端连接和消息

### 全局变量

#### `active_monitors: Dict[str, EmailMonitor]`
**目的**: 存储所有活跃的监控任务  
**结构**: `{connection_id: EmailMonitor实例}`

### 生命周期

#### `async lifespan(app: FastAPI)`
**目的**: 应用启动和关闭时的初始化/清理  
**启动时**:
1. 加载配置(`get_settings()`)
2. 初始化认证(`init_auth()`)
3. 输出配置信息

**关闭时**:
1. 停止所有监控任务
2. 清空 `active_monitors`

### 路由

#### `GET /`
**目的**: 健康检查  
**输出**:
```json
{
  "service": "Rubbish Mail",
  "status": "running",
  "active_connections": 0,
  "timestamp": "2025-10-08T10:00:00"
}
```

#### `WebSocket /ws/monitor`
**目的**: 邮箱监控端点  
**调用链**: `websocket_endpoint -> receive_json -> verify -> EmailMonitor.start -> keep_alive -> stop`

**执行流程**:

1. **接受连接**: `await websocket.accept()`

2. **接收请求**: `await websocket.receive_json()`
   - 解析为 `MonitorRequest`
   - 验证数据格式

3. **验证API密钥**:
   - 调用 `get_auth().verify(api_key)`
   - 失败返回401错误

4. **验证邮箱域名**:
   - 检查邮箱域名是否在 `allowed_domain`
   - 失败返回错误消息

5. **检查连接数限制**:
   - 如果 `len(active_monitors) >= max_connections`
   - 拒绝连接

6. **创建监控器**:
   - 生成 `connection_id`
   - 创建 `EmailMonitor` 实例
   - 定义 `push_callback` 推送函数

7. **启动监控**:
   - 调用 `monitor.start()`
   - 添加到 `active_monitors`
   - 发送 `MonitorStartMessage`

8. **保持连接**:
   - 循环等待客户端消息(30秒超时)
   - 超时发送 `HeartbeatMessage`
   - 异常或断开连接时退出

9. **清理资源**:
   - 从 `active_monitors` 移除
   - 调用 `monitor.stop()`
   - 关闭WebSocket连接

---

## 7. 客户端示例 (example_client.py)

### 职责
- 演示如何使用监控服务
- 提供多种场景示例
- 自动提取验证码

### 类与函数

#### `MailMonitorClient`
**目的**: 邮箱监控客户端封装

##### `__init__(ws_url: str, api_key: str)`
**输入**:
- `ws_url: str` - WebSocket服务地址
- `api_key: str` - API密钥

##### `async monitor(...)`
**目的**: 开始监控邮箱  
**输入**:
- `email: str` - 监控的邮箱
- `keywords: List[str]` - 关键词列表
- `regex_patterns: List[str]` - 正则列表
- `search_in: List[str]` - 搜索范围

**调用链**: `monitor -> connect -> send(request) -> _handle_message`

##### `async _handle_message(message: str)`
**目的**: 处理服务端消息  
**调用链**: `_handle_message -> json.loads -> _extract_verification_code`

**处理消息类型**:
- `monitor_start`: 显示监控状态
- `email_received`: 显示邮件内容并提取验证码
- `error`: 显示错误信息
- `heartbeat`: 静默处理

##### `_extract_verification_code(email_data: dict)`
**目的**: 从邮件中提取验证码  
**输入**: `email_data: dict` - 邮件数据  
**输出**: 验证码字符串 or None

**支持格式**:
- 6位数字: `\d{6}`
- 4位数字: `\d{4}`
- 6位字母数字: `[A-Z0-9]{6}`
- 格式化验证码: `验证码: 123456`, `code: ABC123`

---

## 完整调用链

### 主流程: WebSocket连接 → 监控邮件 → 推送

```
客户端连接
    ↓
main.websocket_endpoint()
    ↓
接收 MonitorRequest
    ↓
get_auth().verify(api_key)  [验证API密钥]
    ↓
检查邮箱域名
    ↓
创建 EmailMonitor 实例
    ↓
EmailMonitor.start()
    ├─ 连接IMAP服务器
    ├─ 登录邮箱
    ├─ 选择INBOX
    └─ 启动 _monitor_loop()
        ↓
    _check_new_emails()  [定期执行]
        ├─ search("UNSEEN")  [搜索未读邮件]
        └─ _process_email(uid)  [处理每封邮件]
            ├─ fetch(uid, RFC822)  [获取邮件内容]
            ├─ _parse_email()  [解析邮件]
            │   ├─ _decode_header_value()  [解码头部]
            │   └─ _get_email_body()  [提取正文]
            ├─ EmailMatcher.match_any(rules, email_data)  [匹配规则]
            │   └─ EmailMatcher.match(rule, email_data)
            │       ├─ _match_keyword()  [关键词匹配]
            │       └─ _match_regex()  [正则匹配]
            ├─ callback(EmailContent)  [推送给客户端]
            │   └─ websocket.send_json(EmailReceivedMessage)
            └─ _mark_as_read(uid)  [标记已读]
```

### 配置加载流程

```
main.py 启动
    ↓
lifespan(app) startup
    ↓
get_settings()
    ├─ load_config("config.yml")
    │   ├─ 读取 config.yml
    │   ├─ 读取 .env 中的 API_KEY
    │   └─ 创建 Settings 实例
    └─ 返回全局配置
        ↓
init_auth(settings.get_valid_api_keys())
    └─ 创建全局 APIKeyAuth 实例
```

### 客户端使用流程

```
MailMonitorClient.monitor()
    ↓
websockets.connect(ws_url)
    ↓
发送 MonitorRequest JSON
    ↓
服务端处理...
    ↓
接收 MonitorStartMessage
    ↓
循环接收消息
    ├─ HeartbeatMessage → 忽略
    ├─ ErrorMessage → 显示错误
    └─ EmailReceivedMessage → 显示邮件
        └─ _extract_verification_code()
```

---

## 数据流向

```
邮件服务器
    ↓ IMAP协议
EmailMonitor
    ├─ 定期检查未读邮件
    ├─ 解析邮件内容
    ├─ 匹配规则
    └─ 如果匹配 → EmailContent
        ↓ WebSocket
客户端
    └─ 接收并处理
```

---

## 关键设计决策

### 1. 为什么选择WebSocket而不是轮询?

**优势**:
- 实时性: 邮件到达后立即推送,无需轮询延迟
- 效率: 长连接复用,减少握手开销
- 双向: 支持心跳保活,及时检测断线

### 2. 为什么每个连接创建独立的EmailMonitor?

**优势**:
- 隔离性: 每个客户端独立监控,互不干扰
- 灵活性: 不同客户端可监控不同邮箱、不同规则
- 资源管理: 连接断开立即释放资源

### 3. 为什么标记已读?

**优势**:
- 避免重复推送同一封邮件
- 减少服务器负载
- 用户可选配置(`mark_as_read`)

### 4. 为什么使用正则和关键词双模式?

**优势**:
- 关键词: 简单易用,适合大部分场景
- 正则: 灵活强大,适合复杂匹配需求
- 组合使用: 满足各种需求

---

## 性能考虑

### 1. 并发连接数限制

**配置**: `monitor.max_connections`  
**原因**: 
- 每个IMAP连接消耗服务器资源
- 防止资源耗尽
- 自用场景通常不需要大量并发

### 2. 检查间隔

**配置**: `monitor.check_interval`  
**权衡**:
- 间隔太短: IMAP服务器压力大
- 间隔太长: 实时性差
- 推荐: 5-10秒

### 3. 已处理邮件缓存

**实现**: `EmailMonitor._processed_uids: set`  
**目的**: 避免重复处理同一封邮件  
**限制**: 内存占用随邮件数量增长

### 4. 异步IO

**技术**: `asyncio` + `aioimaplib`  
**优势**:
- 单线程高并发
- 资源占用低
- 性能优异

---

## 安全性

### 1. API密钥认证

**实现**: `core/auth.py`  
**优势**: 简单有效,适合自用场景  
**建议**: 使用强随机密钥(32位+)

### 2. 域名限制

**配置**: `imap.allowed_domain`  
**目的**: 防止监控未授权的邮箱

### 3. 连接数限制

**配置**: `monitor.max_connections`  
**目的**: 防止资源耗尽攻击

### 4. 敏感信息保护

**实现**:
- API密钥存于 `.env`(不提交版本控制)
- 邮箱密码存于 `config.yml`(不提交)
- `.gitignore` 忽略敏感文件

---

## 错误处理

### 1. IMAP连接错误

**位置**: `EmailMonitor.start()`  
**处理**:
- 捕获 `ConnectionError`
- 记录日志
- 向客户端发送错误消息
- 清理资源

### 2. 邮件解析错误

**位置**: `EmailMonitor._parse_email()`  
**处理**:
- 捕获异常
- 记录警告日志
- 跳过该邮件,继续处理下一封

### 3. 正则表达式错误

**位置**: `EmailMatcher._match_regex()`  
**处理**:
- 捕获 `re.error`
- 返回错误描述
- 不影响其他规则

### 4. WebSocket断线

**位置**: `main.websocket_endpoint()`  
**处理**:
- 捕获 `WebSocketDisconnect`
- 停止监控任务
- 清理资源
- 记录日志

---

## 扩展性

### 未来可能的扩展

1. **多邮箱账户支持**
   - 配置文件支持多个邮箱账户
   - 客户端请求时指定使用哪个账户

2. **Webhook推送**
   - 除了WebSocket,支持HTTP POST推送
   - 适合无法保持长连接的场景

3. **邮件附件下载**
   - 解析附件并提供下载链接
   - 或直接推送附件Base64

4. **持久化规则**
   - 支持保存常用规则到数据库
   - 客户端可复用规则

5. **Web管理面板**
   - 可视化管理监控任务
   - 查看历史邮件
   - 统计分析

---

## 测试建议

### 单元测试

1. **EmailMatcher测试**
   - 关键词匹配(中文/英文/大小写)
   - 正则匹配(各种模式)
   - 边界条件(空模式/空内容)

2. **配置加载测试**
   - 正常配置
   - 缺失字段
   - 格式错误

3. **认证测试**
   - 正确密钥
   - 错误密钥
   - 多密钥

### 集成测试

1. **IMAP连接测试**
   - 成功连接
   - 连接失败
   - 超时

2. **邮件解析测试**
   - 纯文本邮件
   - HTML邮件
   - Multipart邮件
   - 特殊编码

3. **WebSocket测试**
   - 连接/断开
   - 消息收发
   - 错误处理

---

## 总结

本项目采用现代化的异步架构,实现了一个**高效、灵活、易用**的邮箱监控服务。

**核心优势**:
- ⚡ 异步高性能
- 🎯 规则匹配灵活
- 📨 实时推送
- 🔒 安全可控
- 📦 开箱即用

**适用场景**:
- 自动化脚本邮箱验证
- 邮件通知监控
- 临时邮箱服务

**代码质量**:
- ✅ 类型安全(Pydantic)
- ✅ 完整注释(输入/输出/目的)
- ✅ 异常处理完善
- ✅ 日志记录详细
- ✅ 结构清晰模块化

